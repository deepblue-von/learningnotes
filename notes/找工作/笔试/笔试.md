# 1. 虚函数、虚表、虚指针解释一下，分别在哪个时间段创建的

虚函数：类中通过virtual关键字声明的函数，允许在派生类中被重写，实现多态。

虚表（虚函数表）：一个存储类的虚函数地址的表，在编译时期创建，每个含有虚函数的类都有一个虚表。

虚指针（vptr）：一个指针，指向对象的虚表，在对象实例化时（运行时）被创建，并初始化指向类的虚表。



# 2. select、poll和epoll的区别解释一下

**select:** 它的文件描述符集合大小有限（通常受FD_SETSIZE宏限制），每次调用都需要复制整个文件描述符集，且在返回后需要遍历整个集合来找出活跃的文件描述符，这让它在处理大量文件描述符时效率较低。

**poll: **类似于select，但它不受文件描述符数量的限制，因为它使用动态数组（而不是固定大小的位数组）。同样，在每次调用时需要复制整个数组，并在返回后遍历数组以找出活跃的文件描述符。

**epoll: **仅在Linux系统上可用，它使用了一个事件列表，所以不需要像select或poll那样复制和遍历整个文件描述符集。epoll在首次监视某个文件描述符时向内核注册文件描述符，之后不需要再次注册，且当文件描述符就绪时，它只返回那些状态发生变化的文件描述符，这大大提高了效率，尤其适合处理大量文件描述符的场景。

# 3. 内存池的原理解释一下

内存池的基本原理是预先在内存中分配一大块连续的空间，并将这块空间划分为大小相等或不等的小块，用于满足程序运行时的内存分配请求。当程序请求分配内存时，内存池会从这些预分配的小块中找到一个合适的块返回，而不是直接向操作系统请求。同样，当内存被释放时，它会返回到内存池中，而不是归还给操作系统。这种方式可以减少频繁向操作系统申请和释放内存所造成的开销和碎片化问题，从而提高内存分配和回收的效率。 



# 4. 左值应用和右值引用的区别解释一下，为什么需要右值

在 C++ 中，左值（lvalue）和右值（rvalue）的概念与赋值操作紧密相关，它们定义了对象的生存期和是否可以有地址。

1. **左值引用（Lvalue Reference）**：
   - 左值引用是对其可以取地址的持久对象的引用。它们通常用于修改已经存在的对象，并且可以通过 `&` 运算符取得它们的地址。
   - 左值必须有一个明确的存储位置，它们通常与对象的生命周期相关联，可以出现在赋值表达式的左边或右边。
2. **右值引用（Rvalue Reference）**：
   - 右值引用是对其不能取地址的临时对象的引用，这些临时对象通常是函数调用的结果，或者是即将被销毁的对象。
   - 右值引用允许程序员安全地转移资源（如动态内存、文件句柄等）的所有权，而不是进行昂贵的拷贝操作。

C++11 引入了右值引用，主要基于以下原因：

- **移动语义（Move Semantics）**：右值引用使得程序能够区分资源的移动操作和拷贝操作。移动操作不会产生新的资源副本，而是将资源的所有权从一个对象转移到另一个对象。这对于提高涉及动态资源的程序的性能至关重要。
- **完美转发（Perfect Forwarding）**：在模板编程中，右值引用允许函数完美地转发参数，保持参数的值类别（左值或右值）。这意味着模板函数可以将其接收到的参数以原封不动的方式转发给其他函数，这在实现通用库或框架时非常有用。
- **优化性能**：通过右值引用，编译器和程序员可以避免不必要的拷贝，从而优化程序性能。

例如，考虑以下代码：

```cpp
std::vector<int> createVector() {
    return std::vector<int>(100, 10);
}

void someFunction(std::vector<int> vec) {
    // ...
}

int main() {
    someFunction(createVector());
}
```

在 C++11 之前，即使 `createVector` 返回的是一个临时 `vector`，`someFunction` 也会强制创建这个临时对象的副本。有了右值引用，编译器可以识别出这个临时对象可以被移动而不是拷贝，从而提高效率。

```cpp
void someFunction(std::vector<int>&& vec) {
    // ...
}
```

在这个例子中，`someFunction` 可以接受一个右值引用作为参数，从而允许移动操作而不是拷贝。这是 C++11 及以后版本中性能优化的一个关键特性。

# 5. 智能指针的基本原理

智能指针的基本原理是通过封装一个原始指针，在对象的生命周期管理上提供自动化处理

引用计数在std::shared_ptr中默认是线程安全的，即多个线程同时创建或销毁同一shared_ptr实例是安全的，因为修改引用计数的操作是原子的。

智能指针的线程安全性取决于其操作。对于智能指针本身的管理（如赋值和析构），std::shared_ptr是线程安全的。但是，多个线程访问智能指针管理的对象并不一定是线程安全的，需要额外的同步机制来保护被管理对象。

# 6. 多线程访问单例怎么办

双重检查锁定模式（Double-Check Locking）。步骤如下：

在访问单例对象之前，首先检查对象是否已经被创建，以避免锁定开销。

若单例对象未被创建，则进入同步块。同步块内部再次检查对象是否已创建，以防止多个线程同时通过第一次检查。

如果确认单例对象未被创建，此时创建单例实例。 

```cpp
#include <mutex>

class Singleton {
public:
    static Singleton& getInstance() {
        std::call_once(Singleton::onceFlag, Singleton::createInstance);
        return *Singleton::instance;
    }

private:
    static std::once_flag onceFlag;
    static Singleton* instance;

    static void createInstance() {
        instance = new Singleton();
    }

    // 私有构造函数，防止外部实例化
    Singleton();
};

std::once_flag Singleton::onceFlag;
Singleton* Singleton::instance = nullptr;

// 使用
Singleton& singletonRef = Singleton::getInstance();
```



# 7. stl::vector数据存在哪里？为什么不能在栈上？

std::vector的数据实际存储在堆（Heap）上。这是因为std::vector需要能够动态地增长或缩小其大小，而堆内存提供了动态内存分配的能力。栈（Stack）上的空间是有限且固定大小的，适合存储大小在编译时期就已确定的局部变量，不适合存储大小可变的std::vector。



# 8. 为什么栈比堆快

栈比堆更快主要是因为其内存分配方式和访问速度。栈内存由操作系统自动管理，分配和释放速度非常快，因为它使用连续的内存块，并以后进先出的顺序进行访问。相反，堆内存分配更为灵活但也更复杂，需要程序员手动分配和释放，且可能产生内存碎片，这会影响访问速度。此外，栈内存访问通常涉及更少的指令和间接性。 

# 9. unordered_map底层是什么？ 

unordered_map底层实现是一个哈希表。它通过使用哈希函数来把键转换为哈希值，然后根据这个哈希值把元素存储在相应的桶中。在碰到哈希冲突时，会通过链接法解决，即在同一桶中用链表链接存储所有哈希值相同的元素。



# 10. 在main之前和之后执行的是什么

**main函数执行之前，主要就是初始化系统相关资源：**

+ 设置栈指针
+ 初始化静态static变量和global全局变量，即.data段的内容
+ 将未初始化部分的全局变量赋初值：数值型short，int，long等为0， bool为FALSE，指针为NULL等等，即.bss段的内容
+ 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
+ 将main函数的参数argc, argv等传递给main函数，然后才真正运行main函数
+ `__attribute__((constructor))`

**main函数执行之后：**

+ 全局对象的析构函数会在main函数之后执行；
+ 可以用`atexit`注册一个函数，他会在main之后执行；
+ `__attribute__((destructor))`

**深入理解计算机系统 bss段，data段，text段，堆heap和栈stack**

> bss段：
>
> ​		bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域
>
> ​		bss（block started by symbol）
>
> ​		bss段属于静态内存分配
>
> data段：
>
> ​		数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域
>
> ​		数据段属于静态内存分配
>
> text段：
>
> ​		代码段通常是指用来存放程序执行代码的一块内存区域
>
> ​		这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读（某些架构也允许代码段为可写，即允许修改程序）
>
> ​		在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等
>
> 堆：
>
> ​		堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
>
> ​		当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）
>
> ​		当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
>
> 栈：
>
> ​		栈又称为对战，使用户存放程序临时创建的局部变量
>
> ​		也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）
>
> ​		除此之外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中
>
> 　　由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。
>
> 　　从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区

