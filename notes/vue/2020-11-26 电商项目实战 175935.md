### 电商项目实战 

### Git

==git status==检查工作区是否干净
**创建一个新分支**
```powershell
git checkout -b login //创建了名为login的分支
```
**查看所有分支**

```powershell
git branch 
```

==提交代码==

**添加代码到暂存区**

```cmd
git status
git add .
```

**提交代码到本地**

```cmd
git commit -m "完成了登录功能"
```

**切换分支**

```cmd
git checkout master // 切换到主分支
```

**合并分支**

```cmd
 git merge login //切换到主分支执行，将login分支合并
```

**远程推送**

```cmd
git push
```

***将本地 login分支提交到云端***

```cmd
git checkout login
git push -u origin login
```



### 路由

写好的组件要通过路由导入

```js
import Login from './components/Login.vue'
```



```js
const router = new VueRouter({
  routes: [
    { path:  '/', redirect: '/login' }, //当访问到/时，转到/login
    { path: '/login', component: Login }//当用户访问/login时，通过component属性指定要展示的组件
  ]
})
```

在根组件写路由占位符

```vue
<trmplate>
	<div id="app">
        <!-- 路由占位符 -->
        <router-view></router-view>
    </div>
</trmplate>
```



==main.js 文件==

```js
import './路径'
```

### 登录界面

写好全局样式，需要在main.js中导入

#### 登录表单

```vue
<el-form :model="loginFrom" label-width="0px" class="login_form">
    //用:model 绑定数据对象，数据对象要在data中进行定义
```

**element-ui按需导入**

```js
import { Form, FormItem } from 'element-ui'
import { Input } from 'element-ui'


Vue.use(Form)//Vue.use()注册为全局可用的对象
Vue.use(FormItem)
Vue.use(Input)
```



##### 数据绑定

```vue
 <!-- 登录表单区域 -->
      <el-form ref="loginFormRef" :model="loginFrom" :rules="loginFormRules" label-width="0px" class="login_form">
        <!-- :model数据绑定，在表单上填写的数据会自动同步到loginForm对象上，loginForm需要在行为区定义 -->
          <!-- 用户名区域 -->
        <el-form-item prop='username'>
          <el-input v-model="loginFrom.username" prefix-icon="el-icon-user"></el-input>  <!-- 通过v-model绑定到model对象对应的属性上-->
        </el-form-item>
        <!-- 密码区域 -->
          <el-form-item prop='password'>
          <el-input v-model="loginFrom.password" prefix-icon="el-icon-lock"
          type="password"></el-input>
        </el-form-item>
          
```

**行为区定义**

```js
export default {
    data(){
		return {
            //这是登录表单的数据对象
            loginFrom:{}
        }
    }
}
```



**校验规则**

```vue
<el-form :model="loginFrom" :rules="loginFormRules" label-width="0px" class="login_form"> // 1.表单中添加绑定rules属性,绑定值是一个保单的验证规则对象

<!-- 用户名区域 --> // 3.在表单item项中用prop属性指定不同的校验规则
        <el-form-item prop='username'>
          <el-input v-model="loginFrom.username" prefix-icon="el-icon-user">
            </el-input>
        </el-form-item>
```

```js
// 2.定义校验规则
rules:{
	username:[
          { required: true, message: '请输入用户名称', trigger: 'blur' },
          { min: 3, max: 5, message: '长度在 3 到 10 个字符', trigger: 'blur' }
        ]
} 
```

**重置表单**

​        获取表单的实例对象，调用resetField方法对表单进行重置

```vue
<el-form ref="loginFormRef" :model="loginFrom" :rules="loginFormRules" label-width="0px" class="login_form">
    <!-- 通过ref为表单添加一个引用-->
    
el-button type="info" @click="resetLoginForm">重置</el-button>

methods:{
    //点击重置按钮，点击重置表单
    resetLoginForm(){
      // console.log(this)
      this.$refs.loginFormRef.resetFields();
    },
```



**methods-login**

```js
login(){
      this.$refs.loginFormRef.validate(async valid => {
        if(!valid) return;
        const {data:res} = await this.$http.post("login",this.loginForm);
          //start request by this.$http, and using post 
          //the address is login,param: 'username' and 'password' 
          //如果返回对象是promise都可以用async/await来简化此次操作，
          //promise对象中只有data是后台返回的，其他都是axios封装的，可以通过{data:res}
          //将data解构出来
        console.log(result);
       if(res.meta.status !== 200) return this.$message.error("登录失败");
          this.$message.success("登录成功")；
          
     //将登录之后的token，保存到客户端的sessionStorage中
          //  1.1项目中除了token外的其他API接口，必须在登录之后才能访问
          //  1.2token只应在当前网站打开期间生效，所以将token保存在sessionStorage中
          window.sessionStorage.setItem("token",res.data.token); 
          
      });
    //2.通过编程式导航跳转到后台主页，路由地址/home
          this.$router.push("/home");
    }
```

**在路由文件中挂载路由导航守卫**

```js
/挂载路由导航守卫
router.beforeEach((to, from, next) =>{
    //to表示将要访问的路径
    //from表示从哪个路径跳转而来
    //next是一个函数，表示放行
    // next()   放行     next('/login')  强制跳转

    if(to.path === '/login') return next()
    //获取token
    const tokenStr = window.sessionStorage.getItem('token')
    if(!tokenStr) return next('/login')
    next()
})
```

### 主页

**两层for 循环为侧边栏添加数据**

```vue
 <el-aside width="200px">
          <!--侧边栏菜单区-->
           <el-menu
      background-color="#333744"
      text-color="#fff"
      active-text-color="#ffd04b">
      <!-- 一级菜单 -->
      <el-submenu :index="item.id + ''" v-for= "item in menuList" :key="item.id">
          <!--每一个 v-for 都尽量提供一个唯一的 key 属性; 为了能让每一个子菜单单独控制，为每个子菜单绑定唯一的index，index默认接收字符串类型的数据所以在后面拼接一个空字符串-->
          <!-- 一级菜单的模板区域 -->
        <template slot="title">
            <!-- 图标 -->
          <i class="el-icon-location"></i>
          <!-- 文本 -->
          <span>{{item.authName}}</span>
        </template>
        <el-menu-item :index ="subItem.id + ''" v-for="subItem in item.children" :key="subItem.id">
            <template slot="title">
          <i class="el-icon-location"></i>
          <span>{{subItem.authName}}</span>
        </template>
        </el-menu-item>
      </el-submenu>
      
    </el-menu>
 </el-aside>   
```



#### 主题区域

**1.** 首先定义Welcome的组件

**2.**在main处放置路由占位符

```vue
<el-main>
	<router-view></router-view>
</el-main>
```



**3.**将welcome路由设为home路由的子路由

```js
 {
      path: '/home',
      component: Home, 
      redirect:'/welcome',  //重定向到welcome
      children: [{ path: '/welcome', component: Welcome },{ path:'/users', component: Users}]
    }
```

#### 子菜单

在侧边栏区开启router属性，值为true

```vue
  <!-- 二级菜单 -->
        <el-menu-item :index =" '/' + subItem.path" v-for="subItem in item.children" :key="subItem.id" 
        @click="saveNavState('/' + subItem.path)">
```

*subItem.path就是子菜单的id值

#### 二级菜单高亮

**1.**单价二级菜单时将index值保存在sessionStorage中

```vue
<el-menu-item :index =" '/' + subItem.path" v-for="subItem in item.children" :key="subItem.id" 
        @click="saveNavState('/' + subItem.path)">
```



```js
saveNavState(activePath){
  window.sessionStorage.setItem('activePath',activePath)
}//引号里是自己起的名字，后面的activePath是传进来的值
```

==打开application界面可以查看sessionStorage中保存的值==

**2.**将激活菜单的index值动态绑定到侧边栏的default-active属性中  ==属性绑定要加：==

```vue
       <!--侧边栏菜单区-->
           <el-menu background-color="#333744" text-color="#fff" active-text-color="#409EFF" :unique-opened="true" :collapse="isCollapse" :collapse-transition="false" :router="true" :default-active='activePath'>
```

**3.**在home组件被创建时动态赋值

```js
    created(){
        this.getMenuList()
        this.activePath = window.sessionStorage.getItem('activePath')
    },
    saveNavState(activePath){
      window.sessionStorage.setItem('activePath',activePath)
      this.activePath = activePath
    }
```



### 全局样式

assets-css-global.css

```css
/* 全局样式表 */
html, body, #app {
    height: 100%;
    margin: 0;
    padding: 0;
}
.el-breadcrumb {
    margin : 15px;
    font-size: 12px;
}
.card {
    box-shadow: 0 1px rgba(0, 0, 0, 0.15) !important; 
    /*自己的样式要想覆盖原来的样式最好加上！impottant*/
}
```



### 表格

```vue
<!--用户列表区域-->
 <el-table :data="userlist" border="true" stripe>
        <el-table-column label="#" type="index"></el-table-column>
        <el-table-column label="姓名" prop="username"></el-table-column>
        <el-table-column label="状态">
            <!--通过作用域插槽添加操作开关-->
             <template slot-scope="scope">
               <el-switch v-model="scope.row.mg_stste"> </el-switch>
             </template>
        </el-table-column>
 </el-table>     
```

#### 表单

**表单清空**
1.为表单绑定close事件
2.表单清空方法
```js
4.  addDialogClosed(){
       this.$refs.addFormRef.resetFields()//调用resetFields()重置表单的引用
      }
```
### 用户列表

#### 点击用户列表展示表格

**1.**创建users组件

**2.** 创建路由

+ 导入组件-在home组件路由规则的children属性中添加路由规则

```js
{
      path: '/home',
      component: Home, 
      redirect:'/welcome',
      children: [{ path: '/welcome', component: Welcome },{ path:'/users', component: Users}]
    }
```

#### 面包屑组件

```vue
 <el-breadcrumb separator-class="el-icon-arrow-right">
      <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item>用户管理</el-breadcrumb-item>
      <el-breadcrumb-item>用户列表</el-breadcrumb-item>
    </el-breadcrumb>
```

#### 卡片视图区

```vue
<el-card>

</el-card>
```

#### 获取用户列表数据

```js
export default {
	data() {
		return {
            //获取用户列表的参数对象
            queryInfo:{ query:'', pagenum: 1, pagesize: 2 }
			userlist: [],
            total: 0
		}
	},
	created() {
		this.getUserList() //1.在声明周期函数中发起数据请求
	},
	methods: {
      async getUserList() {
      const { data: res } = await this.$http.get("users地址", {
        params: this.queryInfo
      }); //解构出data属性，重命名为res
      if (res.meta.status !== 200) {
        return this.$message.error("获取用户列表失败！");
      }
      this.userlist = res.data.users;
      this.total = res.data.total;
    },
    }
}
```

**用户列表区**

```vue
 <el-table :data="userlist" border stripe>
        <el-table-column label="#" type="index"></el-table-column>
        <el-table-column label="姓名" prop="username"></el-table-column>
</el-table>
```

==**note**==

	1. :data绑定数据源
 	2. prop姓名所对应的值

#### 作用域插槽渲染状态列

```vue
<el-table-column label="状态">
    <template slot-scope="scope"> <!--slot-scope="scope"接收当前作用域的数据-->
      <el-switch
        v-model="scope.row.mg_state" <!--scope.row.mg_state拿到状态-->
        @change="userStateChanged(scope.row)" 
      ></el-switch>
    </template>
</el-table-column>
```

**修改状态**

```js
async userStateChanged(userinfo) {
      const { data: res } = await this.$http.put(
        `users/${userinfo.id}/state/${userinfo.mg_state}`
      );
      if (res.meta.status !== 200) {
        userinfo.mg_state = !userinfo.mg_state;
        return this.$message.error("更新用户状态失败！");
      }
      this.$message.success("更新用户状态成功！");
}
```

  调用$http.post来修改用户状态信息，

**==note==**

v-model做双向数据绑定将开关的状态和当前列的状态绑定在一起

#### 作用域插槽渲染操作列

```vue
<template slot-scope="scope">
   <!-- 修改按钮 -->
 <el-button type="primary" icon="el-icon-edit"
    size="mini" @click="showEditDialog(scope.row.id)"></el-button>
 <el-tooltip effect="dark" content="分配角色" placement="top" :enterable="false">
    <el-button type="warning" icon="el-icon-setting" size="mini"></el-button>
 </el-tooltip>
</template>
```

==**note**== el-tooltip提示信息    :enterable鼠标是否会进入到tooltip中

**用css控制button颜色**

```css
.el-button--warning {
  // color:purple;
  background-color: purple;
}
.el-button--warning:hover {
  background-color: purple;
}
```

 A的四个伪类
	 :link 未被访问前的样式表属性
	 :visited 其链接地址已被访问过时的样式表属性
	 :active 用户激活（在鼠标点击与释放之间发生的事件）时的样式表属性
	 :hover 鼠标悬停时hover
	 写法：a:link/:visited/:hover/:active 或者a:link/:visited/:active/:hover 顺序不能互换

#### 分页

```vue
<el-pagination
   @size-change="handleSizeChange"
   @current-change="handleCurrentChange"
   :current-page="queryInfo.pagenum"
   :page-sizes="[1, 2, 5, 10]"
   :page-size="queryInfo.pagesize"
   layout="total, sizes, prev, pager, next, jumper"
   :total="total"
 >
</el-pagination>
```

==**note**==

**@size-change** 监听页面大小的改变

**@current-change** 监听页码值的改变

**layout** 用来指定页面上显示的内容

```js
//监听pagesize改变的事件
    handleSizeChange(newSize) {
      this.queryInfo.pagesize = newSize;
      this.getUserList(); //重新获取数据
    },
//监听页码值的改变
    handleCurrentChange(newPage) {
      this.queryInfo.pagenum = newPage;
      this.getUserList();
    },
```

#### 查询用户数据

```vue
<el-input
          placeholder="请输入内容"
          v-model="queryInfo.query"  <!--1.双向数据绑定-->
          clearable
          @clear="getUserList()"
          >
    <el-button
          slot="append"
          icon="el-icon-search"
          @click="getUserList()"  <!--点击按钮之后调用getUserList自动模糊搜索-->
    ></el-button>
</el-input>
```

